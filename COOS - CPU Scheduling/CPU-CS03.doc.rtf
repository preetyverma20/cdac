{\rtf1\ansi\ansicpg1252\uc1\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f60\froman\fcharset238\fprq2 Times New Roman CE;}{\f61\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f63\froman\fcharset161\fprq2 Times New Roman Greek;}
{\f64\froman\fcharset162\fprq2 Times New Roman Tur;}{\f65\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f66\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f67\froman\fcharset186\fprq2 Times New Roman Baltic;}
{\f68\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f70\fswiss\fcharset238\fprq2 Arial CE;}{\f71\fswiss\fcharset204\fprq2 Arial Cyr;}{\f73\fswiss\fcharset161\fprq2 Arial Greek;}{\f74\fswiss\fcharset162\fprq2 Arial Tur;}
{\f75\fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f76\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f77\fswiss\fcharset186\fprq2 Arial Baltic;}{\f78\fswiss\fcharset163\fprq2 Arial (Vietnamese);}{\f80\fmodern\fcharset238\fprq1 Courier New CE;}
{\f81\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f83\fmodern\fcharset161\fprq1 Courier New Greek;}{\f84\fmodern\fcharset162\fprq1 Courier New Tur;}{\f85\fmodern\fcharset177\fprq1 Courier New (Hebrew);}
{\f86\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f87\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f88\fmodern\fcharset163\fprq1 Courier New (Vietnamese);}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;
\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;
\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\*\cs10 \additive \ssemihidden 
Default Paragraph Font;}{\*\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1024\langfe1024\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}{\s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\f2\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext15 \styrsid13458800 Plain Text;}}{\*\rsidtbl \rsid869900\rsid1851683\rsid3545237\rsid3565317\rsid3617368\rsid3695614\rsid3829219\rsid4225791\rsid4289350\rsid4789413\rsid4934980
\rsid5127189\rsid5646542\rsid5979412\rsid6257910\rsid6387502\rsid6517298\rsid7954212\rsid8474026\rsid8785128\rsid8921563\rsid9241218\rsid10444896\rsid11027616\rsid12941189\rsid13458800\rsid14157638\rsid14832136\rsid15402198\rsid15470797}
{\*\generator Microsoft Word 10.0.2627;}{\info{\title # include "header}{\author Hemant Bhatye}{\operator Hemant Bhatye}{\creatim\yr2003\mo2\dy8\hr14\min45}{\revtim\yr2003\mo2\dy8\hr14\min50}{\version31}{\edmins5}{\nofpages25}{\nofwords5249}
{\nofchars29922}{\*\company Trigyn Technologies}{\nofcharsws35101}{\vern16437}}\margl1319\margr1319 \widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\formshade\horzdoc\dgmargin\dghspace180\dgvspace180\dghorigin1319
\dgvorigin1440\dghshow1\dgvshow1\jexpand\viewkind1\viewscale114\viewzk2\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule\nobrkwrptbl\snaptogridincell\allowfieldendsel
\wrppunct\asianbrkrule\rsidroot13458800 \fet0\sectd \linex0\endnhere\sectlinegrid360\sectdefaultcl\sectrsid13458800\sftnbj {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}
{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}
{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain 
\s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 \f2\fs20\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {\f1\insrsid5646542\charrsid6517298 # include "header.h"
\par 
\par int main()
\par \{
\par \tab int option;
\par \tab askInputOptions();
\par \tab while(1)
\par \tab \{
\par \tab \tab clrscr();
\par \tab \tab printf("\\n\\t\\t       ====================================");
\par \tab \tab printf("\\n\\t\\t       CPU SCHEDULING ALGORITHMS SIMULATION");
\par \tab \tab printf("\\n\\t\\t       ====================================");
\par \tab \tab printf("\\n\\n\\t\\t\\t1 : First Come First Serve (Non-Preemptive)\\n");
\par \tab \tab printf("\\n\\t\\t\\t2 : Shortest Process Next (Non-Preemptive)\\n");
\par \tab \tab printf("\\n\\t\\t\\t3 : Shortest Remaining Time (Preemptive)\\n");
\par \tab \tab printf("\\n\\t\\t\\t4 : Round Robin (Preemptive)\\n");
\par \tab \tab printf("\\n\\t\\t\\t5 : View input processes\\n");
\par \tab \tab printf("\\n\\t\\t\\t6 : Change input specifications\\n");
\par \tab \tab printf("\\n\\t\\t\\t7 : Generate New Set of Input Processes\\n");
\par \tab \tab printf("\\n\\t\\t\\t8 : Compare all results\\n");
\par \tab \tab printf("\\n\\t\\t\\t9 : Quit\\n");
\par \tab \tab printf("\\n\\n\\t\\t\\tChoose the appropriate option : ");
\par \tab \tab scanf("%d",&option);
\par \tab \tab schedule(option);
\par \tab \}
\par \tab return 0;
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid15470797 {\f1\insrsid15470797\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid15470797 ********}{\f1\insrsid15470797\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void freeMemory()
\par \{
\par \tab struct Process *currProcess, *tempProcess;
\par \tab struct IO_Opn  *curr_io, *temp_io;
\par \tab // free up opQ
\par \tab currProcess = opQhead;
\par \tab while (currProcess!=NULL)
\par \tab \{
\par \tab \tab tempProcess = currProcess->next;
\par \tab \tab free (currProcess);
\par \tab \tab currProcess = tempProcess;
\par \tab \}
\par \tab // free up ipQ
\par \tab currProcess = ipQhead;
\par \tab while (currProcess!=NULL)
\par \tab \{
\par \tab \tab tempProcess = currProcess->next;
\par \tab \tab curr_io = currProcess->io_head;
\par \tab \tab while (curr_io!=NULL)
\par \tab \tab \{
\par \tab \tab \tab temp_io = curr_io->next;
\par \tab \tab \tab free (curr_io);
\par \tab \tab \tab curr_io = temp_io;
\par \tab \tab \}
\par \tab \tab free (currProcess);
\par \tab \tab currProcess = tempProcess;
\par \tab \}
\par \tab ipQhead = NULL;
\par \tab opQhead = NULL;
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid15470797 {\f1\insrsid15470797\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid15470797 ********}{\f1\insrsid15470797\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 int printSimulationOptions()
\par \{
\par \tab int option;
\par \tab printf("\\n\\n\\t\\t\\t1 : See results with simulation");
\par \tab printf("\\n\\n\\t\\t\\t2 : See results without simulation");
\par \tab printf("\\n\\n\\n\\t\\t\\tEnter your choice : ");
\par \tab scanf("%d",&option);
\par \tab printf("\\n\\n");
\par \tab clrscr();
\par \tab return(option);
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid3829219 {\f1\insrsid3829219\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid3829219 ********}{\f1\insrsid3829219\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void compareResults()
\par \{
\par \tab FILE *fp;
\par \tab int i;
\par \tab int temp1;
\par \tab double temp2;
\par \tab char * algofile[] = \{
\par }{\f1\insrsid3829219 \tab \tab \tab \tab }{\f1\insrsid5646542\charrsid6517298 "FCFS.TXT",
\par \tab \tab \tab \tab "SPN.TXT",
\par \tab \tab \tab \tab "SRT.TXT",
\par \tab \tab \tab \tab "RR.TXT"
\par }{\f1\insrsid3829219 \tab }{\f1\insrsid5646542\charrsid6517298 \tab \tab \};
\par \tab char * algoname[] = \{
\par \tab \tab \tab \tab "FCFS",
\par \tab \tab \tab \tab "SPN",
\par \tab \tab \tab \tab "SRT",
\par \tab \tab \tab \tab "RR"
\par \tab \tab \tab }{\f1\insrsid3829219 \tab }{\f1\insrsid5646542\charrsid6517298 \};
\par 
\par \tab ipQhead = loadInputFromFile();
\par \tab opQhead = NULL;
\par \tab first_come_first_serve(2);
\par 
\par \tab ipQhead = loadInputFromFile();
\par \tab opQhead = NULL;
\par \tab shortest_process_next(2);
\par 
\par \tab ipQhead = loadInputFromFile();
\par \tab opQhead = NULL;
\par \tab shortest_remaining_time(2);
\par 
\par \tab ipQhead = loadInputFromFile();
\par \tab opQhead = NULL;
\par \tab round_robin(2,3);
\par 
\par \tab clrscr();
\par \tab printf("\\n\\n\\t\\t\\tCOMPARISON OF ALL RESULTS");
\par \tab printf("\\n\\t\\t\\t=========================");
\par \tab printf("\\n\\n\\tTotal T     Avg.TAT    Throughput    CPU Util    CPU Util(Productive)");
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid4934980\charrsid6517298 }{\f1\insrsid5646542\charrsid6517298 
\par \tab for (i=0;i<4;i++)
\par \tab \{
\par \tab \tab int j;
\par \tab \tab fp = fopen(algofile[i],"r");
\par 
\par \tab \tab printf("\\n%s",algoname[i]);
\par 
\par \tab \tab fscanf(fp,"%d",&temp1);
\par \tab \tab printf("\\t%5d",temp1);
\par 
\par \tab \tab fscanf(fp,"%lf",&temp2);
\par \tab \tab printf("\\t%10.2lf",temp2);
\par 
\par \tab \tab fscanf(fp,"%lf",&temp2);
\par \tab \tab printf("\\t%3.2lf %",temp2);
\par 
\par \tab \tab fscanf(fp,"%lf",&temp2);
\par \tab \tab printf("\\t%11.2lf %",temp2);
\par 
\par \tab \tab fscanf(fp,"%lf",&temp2);
\par \tab \tab printf("\\t%12.2lf %",temp2);
\par \tab \tab fclose(fp);
\par \tab \}
\par 
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid869900 {\f1\insrsid869900\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid869900 ********}{\f1\insrsid869900\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void add_to_ipQ(struct Process *newProcess)
\par \{
\par \tab struct Process *curr,*prev;
\par \tab if (ipQhead == NULL)
\par \tab \{
\par \tab \tab ipQhead = newProcess;
\par \tab \tab newProcess->next = NULL;
\par \tab \tab return;
\par \tab \}
\par \tab curr = ipQhead;
\par \tab prev = ipQhead;
\par \tab while (newProcess->arrival_time > curr->arrival_time && curr!=NULL)
\par \tab \{
\par \tab \tab prev = curr;
\par \tab \tab curr = curr->next;
\par \tab \}
\par \tab if (curr == NULL)
\par \tab \tab prev->next = newProcess;
\par \tab else
\par \tab \{
\par \tab \tab newProcess->next = curr;
\par \tab \tab prev->next = newProcess;
\par \tab \}
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid5127189 {\f1\insrsid5127189\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid5127189 ********}{\f1\insrsid5127189\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 int rand_num(int start, int end)
\par \{
\par \tab int temp=-1;
\par \tab while (temp < start)
\par \tab \tab temp = random(end+1);
\par \tab return(temp);
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid3617368 {\f1\insrsid3617368\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid3617368 ********}{\f1\insrsid3617368\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void setID()
\par \{
\par \tab int i=1;
\par \tab struct Process *curr;
\par \tab for (curr=ipQhead; curr!=NULL; curr=curr->next)
\par \tab \{
\par \tab \tab curr->process_id = i++;
\par \tab \tab curr->time_left = curr->service_time;
\par \tab \}
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid5979412 {\f1\insrsid5979412\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid5979412 ********}{\f1\insrsid5979412\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void printProcessesInfo()
\par \{
\par \tab int count=0, i;
\par \tab struct IO_Opn *temp_io;
\par \tab struct Process *head;
\par \tab clrscr();
\par \tab head = ipQhead;
\par \tab printf("P_ID Arr_time Ser_time I/O opns I/O Arr I/O burst\\n");
\par \tab if (head!=NULL)
\par \tab \{
\par \tab \tab for (;head!=NULL;head=head->next)
\par \tab \tab \{
\par \tab \tab \tab printf("%2d",head->process_id);
\par \tab \tab \tab printf("%7d",head->arrival_time);
\par \tab \tab \tab printf("%10d",head->service_time);
\par \tab \tab \tab printf("%10d\\n",head->no_io_opns);
\par \tab \tab \tab for (temp_io=head->io_head;temp_io!=NULL;temp_io=temp_io->next)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab printf("%38d",temp_io->io_arrival);
\par \tab \tab \tab \tab printf("%8d\\n",temp_io->io_burst);
\par \tab \tab \tab \}
\par \tab \tab \tab count++;
\par \tab \tab \}
\par \tab \tab printf("\\nTotal number of processes : %d",count);
\par \tab \}
\par \tab getch();
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid15402198 {\f1\insrsid15402198\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid15402198 ********}{\f1\insrsid15402198\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void printResults(FILE *fp,int timecount,int cputime,int no_of_switches)
\par \{
\par \tab struct Process *p;
\par \tab double ntat,throughput,cpu_util, avg_tat, total_tat=0;
\par \tab int cpu_productive;
\par 
\par \tab // time for which the cpu was executing user processes
\par \tab cpu_productive = cputime;
\par 
\par \tab // time for which cpu was executing either user processes or the OS Code
\par \tab cputime += (int)(0.1 * no_of_switches);
\par \tab // total time of simulation
\par \tab timecount += (int)(0.1 * no_of_switches);
\par \tab /* cpu utilisation includes the time for which cpu executes
\par \tab either user processes or the OS Code for process switching */
\par \tab cpu_util = (cputime / (timecount*1.0)) * 100;
\par 
\par \tab printf("\\n ID\\tService Time\\tTAT\\tNormalised TAT");
\par \tab for (p=opQhead;p!=NULL;p=p->next)
\par \tab \{
\par \tab \tab ntat = p->tat / (p->service_time*1.0);
\par \tab \tab total_tat += p->tat;
\par \tab \tab printf("\\n%3d%11d%13d%16lf",p->process_id,p->service_time,p->tat,ntat);
\par \tab \}
\par \tab avg_tat = total_tat/(1.0*no_of_processes);
\par \tab throughput = no_of_processes / (timecount*1.0);
\par \tab printf("\\n\\nTotal time      \tab      : %d",timecount);
\par \tab printf("\\nAverage Turnaround Time      : %3.2lf",avg_tat);
\par \tab printf("\\nThroughput      \tab      : %3.2lf %",throughput*100);
\par \tab printf("\\nCPU Utilisation              : %3.2lf %",cpu_util);
\par \tab printf("\\nCPU Utilisation (Productive) : %3.2lf %",(cpu_productive / (1.0*timecount)) * 100);
\par 
\par \tab fprintf(fp,"%d",timecount);
\par \tab fprintf(fp,"\\n%.2lf",avg_tat);
\par \tab fprintf(fp,"\\n%.2lf",throughput*100);
\par \tab fprintf(fp,"\\n%.2lf",cpu_util);
\par \tab fprintf(fp,"\\n%.2lf",(cpu_productive / (1.0*timecount)) * 100);
\par \tab getch();
\par \tab getch();
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid4225791 {\f1\insrsid4225791\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid4225791 ********}{\f1\insrsid4225791\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void printSimulation(struct Process *curr,int timecount,int cputime, int no_of_switches)
\par \{
\par \tab struct IO_Opn *temp_io;
\par \tab struct Process *temp;
\par \tab clrscr();
\par \tab printf("Input Queue:\\n");
\par \tab printf("============\\n");
\par \tab temp = ipQhead;
\par \tab while (temp!=NULL)
\par \tab \{
\par \tab \tab printf("pid = %02d",temp->process_id);
\par \tab \tab printf(" Arrival time = %02d",temp->arrival_time);
\par \tab \tab printf(" Service time = %02d",temp->service_time);
\par \tab \tab printf("  %d IO opn(s):",temp->no_io_opns);
\par \tab \tab if (temp->io_head!=NULL)
\par \tab \tab \{
\par \tab \tab \tab for (temp_io=temp->io_head;temp_io!=NULL;temp_io=temp_io->next)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab printf(" %d",temp_io->io_arrival);
\par \tab \tab \tab \tab printf(",%d ",temp_io->io_burst);
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \tab temp = temp->next;
\par \tab \tab printf("\\n");
\par \tab \}
\par 
\par \tab temp = readyQhead;
\par \tab printf("\\nReady Queue:\\n");
\par \tab printf("============\\n");
\par \tab while (temp!=NULL)
\par \tab \{
\par \tab \tab printf("pid = %02d",temp->process_id);
\par \tab \tab printf(" Arrival time = %02d",temp->arrival_time);
\par \tab \tab printf(" Time left = %02d",temp->time_left);
\par \tab \tab printf("  %d IO opn(s):",temp->no_io_opns);
\par \tab \tab if (temp->io_head!=NULL)
\par \tab \tab \{
\par \tab \tab \tab for (temp_io=temp->io_head;temp_io!=NULL;temp_io=temp_io->next)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab printf(" %d",temp_io->io_time_left);
\par \tab \tab \tab \tab printf(",%d ",temp_io->io_burst);
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \tab printf(" T = %d",timecount-temp->arrival_time);
\par \tab \tab if (curr == temp)
\par \tab \tab \tab printf("  <---");
\par \tab \tab temp = temp->next;
\par \tab \tab printf("\\n");
\par \tab \}
\par 
\par \tab temp = blockedQhead;
\par \tab printf("\\nBlocked Queue:\\n");
\par \tab printf("==============\\n");
\par \tab while (temp!=NULL)
\par \tab \{
\par \tab \tab printf("pid = %02d",temp->process_id);
\par \tab \tab printf(" Arrival time = %02d",temp->arrival_time);
\par \tab \tab printf(" Time left = %02d",temp->time_left);
\par \tab \tab printf("  %d IO opn(s):",temp->no_io_opns);
\par \tab \tab if (temp->io_head!=NULL)
\par \tab \tab \{
\par \tab \tab \tab for (temp_io=temp->io_head;temp_io!=NULL;temp_io=temp_io->next)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab printf(" %d",temp_io->io_time_left);
\par \tab \tab \tab \tab printf(",%d ",temp_io->io_burst);
\par \tab \tab \tab \}
\par \tab \tab \}
\par 
\par \tab \tab printf(" T = %d",timecount-temp->arrival_time);
\par 
\par \tab \tab temp = temp->next;
\par \tab \tab printf("\\n");
\par \tab \}
\par 
\par \tab temp = opQhead;
\par \tab printf("\\nOutput Queue:\\n");
\par \tab printf("=============\\n");
\par \tab while (temp!=NULL)
\par \tab \{
\par \tab \tab printf("pid = %02d",temp->process_id);
\par \tab \tab printf("\\t\\tTurn Around Time = %02d",temp->tat);
\par \tab \tab temp = temp->next;
\par \tab \tab printf("\\n");
\par \tab \}
\par 
\par \tab printf("\\nTime = %02d",timecount);
\par \tab printf("\\tCPU Time = %02d",cputime);
\par \tab if (timeslice != -1)
\par \tab \tab printf("\\tTimeslice = %02d",timeslice);
\par \tab printf("\\tNo. of Switches = %02d", no_of_switches);
\par \tab printf("\\n\\nPress any key to continue OR q to quit");
\par //\tab sleep(1);
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid6387502 {\f1\insrsid6387502\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid6387502 ********}{\f1\insrsid6387502\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void saveInputToFile()
\par \{
\par \tab FILE *fp;
\par \tab struct IO_Opn *temp_io;
\par \tab struct Process *head;
\par \tab head = ipQhead;
\par 
\par \tab fp = fopen("mainQ.dat","w");
\par \tab fprintf(fp,"%d\\n",no_of_processes);
\par \tab while (head != NULL)
\par \tab \{
\par \tab \tab fprintf(fp,"%d ",head->process_id);
\par \tab \tab fprintf(fp,"%d ",head->arrival_time);
\par \tab \tab fprintf(fp,"%d ",head->service_time);
\par \tab \tab fprintf(fp,"%d ",head->no_io_opns);
\par \tab \tab temp_io = head->io_head;
\par \tab \tab while (temp_io != NULL)
\par \tab \tab \{
\par \tab \tab \tab fprintf(fp,"%d ",temp_io->io_arrival);
\par \tab \tab \tab fprintf(fp,"%d ",temp_io->io_burst);
\par \tab \tab \tab temp_io = temp_io->next;
\par \tab \tab \}
\par \tab \tab fprintf(fp,"\\n");
\par \tab \tab head = head->next;
\par \tab \}
\par \tab fclose(fp);
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid3565317 {\f1\insrsid3565317\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid3565317 ********}{\f1\insrsid3565317\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 struct Process* loadInputFromFile()
\par \{
\par \tab FILE *fp;
\par \tab struct Process *head,*temp;
\par \tab struct IO_Opn *temp_io;
\par \tab int i,n,j;
\par 
\par \tab fp = fopen("mainQ.dat","r");
\par \tab fscanf(fp,"%d\\n",&n);
\par 
\par \tab head = NULL;
\par \tab temp = NULL;
\par 
\par \tab for (i=1;i<=n;i++)
\par \tab \{
\par \tab \tab temp = (struct Process *)malloc (sizeof (struct Process));
\par \tab \tab temp->next = NULL;
\par \tab \tab temp->io_head = NULL;
\par \tab \tab fscanf(fp,"\\n%d ",&(temp->process_id));
\par \tab \tab fscanf(fp,"%d ",&(temp->arrival_time));
\par \tab \tab fscanf(fp,"%d ",&(temp->service_time));
\par \tab \tab fscanf(fp,"%d ",&(temp->no_io_opns));
\par \tab \tab temp->time_left = temp->service_time;
\par \tab \tab for (j=1;j<=temp->no_io_opns;j++)
\par \tab \tab \{
\par 
\par \tab \tab \tab temp_io = (struct IO_Opn *)malloc (sizeof (struct IO_Opn));
\par \tab \tab \tab temp_io->next = NULL;
\par \tab \tab \tab fscanf(fp,"%d ",&(temp_io->io_arrival));
\par \tab \tab \tab fscanf(fp,"%d ",&(temp_io->io_burst));
\par \tab \tab \tab temp_io->io_time_left = temp_io->io_arrival;
\par \tab \tab \tab if (temp->io_head == NULL)
\par \tab \tab \tab \tab temp->io_head = temp_io;
\par \tab \tab \tab else
\par \tab \tab \tab \tab temp->io_head->next = temp_io;
\par \tab \tab \}
\par 
\par \tab \tab if (head == NULL)
\par \tab \tab \tab head = temp;
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab struct Process *curr;
\par \tab \tab \tab curr = head;
\par \tab \tab \tab while (curr->next!=NULL)
\par \tab \tab \tab \tab curr = curr->next;
\par \tab \tab \tab curr->next = temp;
\par \tab \tab \}
\par \tab \}
\par \tab fclose(fp);
\par \tab return(head);
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid3545237 {\f1\insrsid3545237\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid3545237 ********}{\f1\insrsid3545237\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void add_to_opQ (struct Process *newProcess)
\par \{
\par \tab if (opQhead == NULL)
\par \tab \{
\par \tab \tab opQhead = newProcess;
\par \tab \tab newProcess->next = NULL;
\par \tab \}
\par \tab else
\par \tab \{
\par \tab \tab struct Process *curr = opQhead;
\par \tab \tab for (; curr->next!=NULL; curr=curr->next);
\par \tab \tab curr->next = newProcess;
\par \tab \tab newProcess->next = NULL;
\par \tab \}
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid4789413 {\f1\insrsid4789413\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid4789413 ********}{\f1\insrsid4789413\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void add_to_blockedQ (struct Process *newProcess)
\par \{
\par \tab if (blockedQhead == NULL)
\par \tab \{
\par \tab \tab blockedQhead = newProcess;
\par \tab \tab newProcess->next = NULL;
\par \tab \}
\par \tab else
\par \tab \{
\par \tab \tab struct Process *curr = blockedQhead;
\par \tab \tab for (; curr->next!=NULL; curr=curr->next);
\par \tab \tab curr->next = newProcess;
\par \tab \tab newProcess->next = NULL;
\par \tab \tab curr = NULL;
\par \tab \}
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid11027616 {\f1\insrsid11027616\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid11027616 ********}{\f1\insrsid11027616\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void add_to_readyQ (struct Process *newProcess)
\par \{
\par \tab if (readyQhead == NULL)
\par \tab \{
\par \tab \tab readyQhead = newProcess;
\par \tab \tab newProcess->next = NULL;
\par \tab \}
\par \tab else
\par \tab \{
\par \tab \tab struct Process *curr = readyQhead;
\par \tab \tab for (; curr->next!=NULL; curr=curr->next);
\par \tab \tab curr->next = newProcess;
\par \tab \tab newProcess->next = NULL;
\par \tab \}
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid8785128 {\f1\insrsid8785128\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid8785128 ********}{\f1\insrsid8785128\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void first_come_first_serve(int choice)
\par \{
\par \tab int timecount = 0;
\par \tab int cputime   = 0;
\par \tab int no_of_switches = 0;
\par \tab int process_switch = 0;
\par \tab FILE *fp;
\par 
\par \tab io_interrupt  = 0;
\par \tab readyQhead    = NULL;
\par \tab blockedQhead  = NULL;
\par \tab if (choice==1)
\par \tab \{
\par \tab \tab printSimulation(readyQhead,timecount,cputime, no_of_switches);
\par \tab \tab if (getch() == 'q' || getch() == 'Q')
\par \tab \tab \tab choice = 0;
\par \tab \}
\par \tab while (ipQhead!=NULL || readyQhead!=NULL || blockedQhead!=NULL)
\par \tab \{
\par \tab \tab /* check for the interrupt before proceeding to
\par \tab \tab    next instruction cycle */
\par \tab \tab if (io_interrupt)
\par \tab \tab \{
\par \tab \tab \tab struct Process *p;
\par \tab \tab \tab struct IO_Opn *temp_io;
\par 
\par \tab \tab \tab p = blockedQhead->next;
\par \tab \tab \tab blockedQhead->no_io_opns--;
\par \tab \tab \tab temp_io = blockedQhead->io_head;
\par \tab \tab \tab blockedQhead->io_head = blockedQhead->io_head->next;
\par \tab \tab \tab free (temp_io);
\par 
\par \tab \tab \tab // if process needs CPU TIME, add it to ready queue
\par \tab \tab \tab if (blockedQhead->time_left != 0)
\par \tab \tab \tab \tab add_to_readyQ(blockedQhead);
\par \tab \tab \tab // else add it to output queue
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab blockedQhead->tat = timecount - blockedQhead->arrival_time;
\par \tab \tab \tab \tab add_to_opQ(blockedQhead);
\par \tab \tab \tab \}
\par \tab \tab \tab // set interrupt to zero indicating that IO Device is free now
\par \tab \tab \tab io_interrupt = 0;
\par 
\par \tab \tab \tab // remove process from blocked queue
\par \tab \tab \tab blockedQhead = p;
\par \tab \tab \tab process_switch = 1;
\par \tab \tab \}
\par \tab \tab // if process completes execution or requests io operation
\par \tab \tab else if (readyQhead != NULL)
\par \tab \tab \{
\par \tab \tab \tab if (readyQhead->time_left == 0)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab struct Process *p;
\par \tab \tab \tab \tab readyQhead->tat = timecount - readyQhead->arrival_time;
\par \tab \tab \tab \tab p = readyQhead->next;
\par \tab \tab \tab \tab add_to_opQ(readyQhead);
\par \tab \tab \tab \tab readyQhead = p;
\par \tab \tab \tab \tab process_switch = 1;
\par \tab \tab \tab \}
\par \tab \tab \tab // io request
\par \tab \tab \tab else if (readyQhead->io_head != NULL)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab if (readyQhead->io_head->io_time_left == 0)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab struct Process *p;
\par \tab \tab \tab \tab \tab p = readyQhead->next;
\par \tab \tab \tab \tab \tab add_to_blockedQ(readyQhead);
\par \tab \tab \tab \tab \tab readyQhead = p;
\par \tab \tab \tab \tab \tab process_switch = 1;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \tab // if new process arrives
\par \tab \tab if (!process_switch && ipQhead != NULL)
\par \tab \tab \tab if (timecount == ipQhead->arrival_time)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab struct Process *p;
\par \tab \tab \tab \tab \tab p = ipQhead->next;
\par \tab \tab \tab \tab \tab add_to_readyQ(ipQhead);
\par \tab \tab \tab \tab \tab ipQhead = p;
\par \tab \tab \tab \tab \tab process_switch = 1;
\par \tab \tab \tab \tab \}
\par 
\par \tab \tab if (process_switch)
\par \tab \tab \{
\par \tab \tab \tab no_of_switches++;
\par \tab \tab \tab process_switch = 0;
\par \tab \tab \tab if (choice==1)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab printSimulation(readyQhead,timecount,cputime, no_of_switches);
\par \tab \tab \tab \tab if (getch() == 'q' || getch() == 'Q')
\par \tab \tab \tab \tab \tab choice = 0;
\par \tab \tab \tab \}
\par \tab \tab \tab continue;
\par \tab \tab \}
\par \tab \tab /* if io interrupt has not occured, reduce the
\par \tab \tab time left for io_operation completion */
\par \tab \tab if (blockedQhead != NULL)
\par \tab \tab \{
\par \tab \tab \tab blockedQhead->time_left--;
\par \tab \tab \tab if (blockedQhead->io_head->next!=NULL)
\par \tab \tab \tab \tab blockedQhead->io_head->next->io_time_left--;
\par \tab \tab \tab blockedQhead->io_head->io_burst--;
\par \tab \tab \tab /* check whether io operation is completed
\par \tab \tab \tab if yes set io_interrupt to one indicating that
\par \tab \tab \tab process has completed io operation and
\par \tab \tab \tab needs cpu attention */
\par \tab \tab \tab if (blockedQhead->io_head->io_burst == 0)
\par \tab \tab \tab \tab io_interrupt = 1;
\par \tab \tab \}
\par \tab \tab if (readyQhead!=NULL)
\par \tab \tab \{
\par \tab \tab \tab readyQhead->time_left--;
\par \tab \tab \tab if (readyQhead->io_head != NULL)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab readyQhead->io_head->io_time_left--;
\par \tab \tab \tab \tab if (readyQhead->io_head->next != NULL)
\par \tab \tab \tab \tab \tab readyQhead->io_head->next->io_time_left--;
\par \tab \tab \tab \}
\par \tab \tab \tab cputime++;
\par \tab \tab \}
\par \tab \tab timecount++;
\par \tab \tab if (choice==1)
\par \tab \tab \{
\par \tab \tab \tab printSimulation(readyQhead,timecount,cputime, no_of_switches);
\par \tab \tab \tab if (getch() == 'q' || getch() == 'Q')
\par \tab \tab \tab \tab choice = 0;
\par \tab \tab \}
\par \tab \} // while
\par \tab clrscr();
\par //\tab printf("======================\\n");
\par \tab printf("First Come First Serve\\n");
\par \tab printf("======================\\n");
\par 
\par \tab fp = fopen("FCFS.TXT","w");
\par \tab printResults(fp,timecount,cputime,no_of_switches);
\par \tab fclose(fp);
\par \tab freeMemory();
\par \} // fcfs
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid8921563 {\f1\insrsid8921563\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid8921563 ********}{\f1\insrsid8921563\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid8921563 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void shortest_process_next(int choice)
\par \{
\par \tab int timecount = 0;
\par \tab int cputime = 0;
\par \tab struct Process *curr,*prev;
\par \tab int process_switch = 0;
\par \tab int no_of_switches = 0;
\par \tab FILE *fp;
\par 
\par \tab io_interrupt = 0;
\par \tab readyQhead   = NULL;
\par \tab blockedQhead = NULL;
\par \tab curr = NULL;
\par \tab prev = NULL;
\par 
\par \tab if (choice==1)
\par \tab \{
\par \tab \tab printSimulation(readyQhead,timecount,cputime, no_of_switches);
\par \tab \tab if (getch() == 'q' || getch() == 'Q')
\par \tab \tab \tab choice = 0;
\par \tab \}
\par 
\par \tab while (ipQhead!=NULL || readyQhead!=NULL || blockedQhead!=NULL)
\par \tab \{
\par \tab \tab // check for io interrupt
\par \tab \tab if (io_interrupt)
\par \tab \tab \{
\par \tab \tab \tab struct Process *p;
\par \tab \tab \tab struct IO_Opn *temp_io;
\par 
\par \tab \tab \tab p = blockedQhead->next;
\par \tab \tab \tab blockedQhead->no_io_opns--;
\par \tab \tab \tab temp_io = blockedQhead->io_head;
\par \tab \tab \tab blockedQhead->io_head = blockedQhead->io_head->next;
\par \tab \tab \tab free (temp_io);
\par 
\par \tab \tab \tab if (blockedQhead->time_left != 0)
\par \tab \tab \tab \tab add_to_readyQ(blockedQhead);
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab blockedQhead->tat = timecount - blockedQhead->arrival_time;
\par \tab \tab \tab \tab add_to_opQ(blockedQhead);
\par \tab \tab \tab \}
\par \tab \tab \tab io_interrupt = 0;
\par \tab \tab \tab blockedQhead = p;
\par \tab \tab \tab process_switch = 1;
\par \tab \tab \}
\par \tab \tab // check if currently executing process finishes or requests io
\par \tab \tab else if (curr != NULL)
\par \tab \tab \{
\par \tab \tab \tab // check whether currently executing process finishes
\par \tab \tab \tab if (curr->time_left == 0)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab struct Process *p;
\par \tab \tab \tab \tab curr->tat = timecount - curr->arrival_time;
\par 
\par \tab \tab \tab \tab // remove that process from readyQ
\par \tab \tab \tab \tab if (curr == readyQhead)\tab // if process is at the readyQhead
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab p = readyQhead->next;
\par \tab \tab \tab \tab \tab add_to_opQ(readyQhead);
\par \tab \tab \tab \tab \tab readyQhead = p;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab p = curr->next;
\par \tab \tab \tab \tab \tab add_to_opQ(curr);
\par \tab \tab \tab \tab \tab prev->next = p;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab // set currently executing process to null
\par \tab \tab \tab \tab // indicating that processor is now idle
\par \tab \tab \tab \tab curr = NULL;
\par \tab \tab \tab \tab process_switch = 1;
\par \tab \tab \tab \}
\par \tab \tab \tab // if curr process is not finished check whether it requests IO
\par \tab \tab \tab else if (curr->io_head != NULL)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab if (curr->service_time - curr->time_left == curr->io_head->io_arrival)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab struct Process *p;
\par \tab \tab \tab \tab \tab // add process to blockedQ
\par \tab \tab \tab \tab \tab if (curr == readyQhead)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab p = readyQhead->next;
\par \tab \tab \tab \tab \tab \tab add_to_blockedQ(readyQhead);
\par \tab \tab \tab \tab \tab \tab readyQhead = p;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab p = curr->next;
\par \tab \tab \tab \tab \tab \tab add_to_blockedQ(curr);
\par \tab \tab \tab \tab \tab \tab prev->next = p;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab curr = NULL;
\par \tab \tab \tab \tab \tab process_switch = 1;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \} // if (curr ! NULL)
\par 
\par \tab \tab // if new process arrives
\par \tab \tab if (!process_switch && ipQhead != NULL)
\par \tab \tab \tab if (timecount == ipQhead->arrival_time)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab struct Process *p;
\par \tab \tab \tab \tab p = ipQhead->next;
\par \tab \tab \tab \tab add_to_readyQ(ipQhead);
\par \tab \tab \tab \tab ipQhead = p;
\par \tab \tab \tab \tab process_switch = 1;
\par \tab \tab \tab \}
\par 
\par \tab \tab if (process_switch)
\par \tab \tab \{
\par \tab \tab \tab no_of_switches++;
\par \tab \tab \tab process_switch = 0;
\par \tab \tab \tab if (choice==1)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab printSimulation(curr,timecount,cputime, no_of_switches);
\par \tab \tab \tab \tab if (getch() == 'q' || getch() == 'Q')
\par \tab \tab \tab \tab \tab choice = 0;
\par \tab \tab \tab \}
\par \tab \tab \tab continue;
\par \tab \tab \}
\par \tab \tab // check for shortest process next if processor is idle
\par \tab \tab if (curr == NULL && readyQhead != NULL)
\par \tab \tab \{
\par \tab \tab \tab struct Process *temp;
\par \tab \tab \tab int min = 100;
\par \tab \tab \tab temp = readyQhead;
\par \tab \tab \tab prev = NULL;
\par \tab \tab \tab // find out process with minimum time left or service time
\par \tab \tab \tab while (temp!=NULL)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab if (temp->time_left < min)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab min = temp->time_left;
\par \tab \tab \tab \tab \tab curr = temp;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab temp = temp->next;
\par \tab \tab \tab \}
\par \tab \tab \tab // get the pointer to prev process (prev to min)
\par \tab \tab \tab // for manipulations
\par \tab \tab \tab temp = readyQhead;
\par \tab \tab \tab while (temp->next!=NULL)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab if (temp->next == curr)
\par \tab \tab \tab \tab \tab prev = temp;
\par \tab \tab \tab \tab temp = temp->next;
\par \tab \tab \tab \}
\par \tab \tab \tab // special case ie if min process is at the readyQhead
\par \tab \tab \tab if (prev == NULL)
\par \tab \tab \tab \tab prev = curr;
\par \tab \tab \} // if (!process_switch && curr == NULL)
\par 
\par \tab \tab // execute io operation of the process that is in the blockedQhead
\par \tab \tab if (blockedQhead != NULL)
\par \tab \tab \{
\par \tab \tab \tab blockedQhead->time_left--;
\par \tab \tab \tab if (blockedQhead->io_head->next!=NULL)
\par \tab \tab \tab \tab blockedQhead->io_head->next->io_time_left--;
\par \tab \tab \tab blockedQhead->io_head->io_burst--;
\par \tab \tab \tab if (blockedQhead->io_head->io_burst == 0)
\par \tab \tab \tab \tab io_interrupt = 1;
\par \tab \tab \}
\par 
\par \tab \tab // execute the currently available process
\par \tab \tab if (curr != NULL)
\par \tab \tab \{
\par \tab \tab \tab curr->time_left--;
\par \tab \tab \tab if (curr->io_head != NULL)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab curr->io_head->io_time_left--;
\par \tab \tab \tab \tab if (curr->io_head->next != NULL)
\par \tab \tab \tab \tab \tab curr->io_head->next->io_time_left--;
\par \tab \tab \tab \}
\par \tab \tab \tab cputime++;
\par \tab \tab \}
\par \tab \tab timecount++;
\par \tab \tab if (choice==1)
\par \tab \tab \{
\par \tab \tab \tab printSimulation(curr,timecount,cputime, no_of_switches);
\par \tab \tab \tab if (getch() == 'q' || getch() == 'Q')
\par \tab \tab \tab \tab choice = 0;
\par \tab \tab \}
\par \tab \} // while
\par \tab clrscr();
\par \tab printf("Shortest Process Next\\n");
\par \tab printf("=====================\\n");
\par \tab fp = fopen("SPN.TXT","w");
\par \tab printResults(fp,timecount,cputime,no_of_switches);
\par 
\par \tab fclose(fp);
\par \tab freeMemory();
\par \} // spn
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid14157638 {\f1\insrsid14157638\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid14157638 ********}{\f1\insrsid14157638\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void shortest_remaining_time(int choice)
\par \{
\par \tab int timecount = 0;
\par \tab int cputime = 0;
\par \tab struct Process *curr,*prev;
\par \tab int process_switch = 0;
\par \tab int no_of_switches = 0;
\par \tab int readyQ_updated = 0;
\par \tab FILE *fp;
\par 
\par \tab io_interrupt = 0;
\par \tab readyQhead   = NULL;
\par \tab blockedQhead = NULL;
\par \tab curr = NULL;
\par \tab prev = NULL;
\par \tab if (choice==1)
\par \tab \{
\par \tab \tab printSimulation(curr,timecount,cputime, no_of_switches);
\par \tab \tab if (getch() == 'q' || getch() == 'Q')
\par \tab \tab \tab choice = 0;
\par \tab \}
\par 
\par \tab while (ipQhead!=NULL || readyQhead!=NULL || blockedQhead!=NULL)
\par \tab \{
\par \tab \tab // check for io interrupt
\par \tab \tab if (io_interrupt)
\par \tab \tab \{
\par \tab \tab \tab struct Process *p;
\par \tab \tab \tab struct IO_Opn *temp_io;
\par 
\par \tab \tab \tab p = blockedQhead->next;
\par \tab \tab \tab blockedQhead->no_io_opns--;
\par \tab \tab \tab temp_io = blockedQhead->io_head;
\par \tab \tab \tab blockedQhead->io_head = blockedQhead->io_head->next;
\par \tab \tab \tab free (temp_io);
\par 
\par \tab \tab \tab // add process to readyQ
\par \tab \tab \tab if (blockedQhead->time_left != 0)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab add_to_readyQ(blockedQhead);
\par \tab \tab \tab \tab readyQ_updated = 1;
\par \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab blockedQhead->tat = timecount - blockedQhead->arrival_time;
\par \tab \tab \tab \tab add_to_opQ(blockedQhead);
\par \tab \tab \tab \}
\par \tab \tab \tab io_interrupt = 0;
\par \tab \tab \tab blockedQhead = p;
\par \tab \tab \tab process_switch = 1;
\par \tab \tab \}
\par \tab \tab // check whether process finishes
\par \tab \tab else if (curr != NULL)
\par \tab \tab \{
\par \tab \tab \tab if (curr->time_left == 0)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab struct Process *p;
\par \tab \tab \tab \tab curr->tat = timecount - curr->arrival_time;
\par \tab \tab \tab \tab if (curr == readyQhead)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab p = readyQhead->next;
\par \tab \tab \tab \tab \tab add_to_opQ(readyQhead);
\par \tab \tab \tab \tab \tab readyQhead = p;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab else
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab p = curr->next;
\par \tab \tab \tab \tab \tab add_to_opQ(curr);
\par \tab \tab \tab \tab \tab prev->next = p;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab curr = NULL;
\par \tab \tab \tab \tab process_switch = 1;
\par \tab \tab \tab \tab readyQ_updated = 1;
\par \tab \tab \tab \}
\par \tab \tab \tab // check whether process requests IO
\par \tab \tab \tab else if (curr->io_head != NULL)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab if (curr->io_head->io_time_left == 0)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab struct Process *p;
\par \tab \tab \tab \tab \tab if (curr == readyQhead)
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab p = readyQhead->next;
\par \tab \tab \tab \tab \tab \tab add_to_blockedQ(readyQhead);
\par \tab \tab \tab \tab \tab \tab readyQhead = p;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab else
\par \tab \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab \tab p = curr->next;
\par \tab \tab \tab \tab \tab \tab add_to_blockedQ(curr);
\par \tab \tab \tab \tab \tab \tab prev->next = p;
\par \tab \tab \tab \tab \tab \tab curr = NULL;
\par \tab \tab \tab \tab \tab \}
\par \tab \tab \tab \tab \tab curr = NULL;
\par \tab \tab \tab \tab \tab process_switch = 1;
\par \tab \tab \tab \tab \tab readyQ_updated = 1;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \} // if (curr != NULL)
\par 
\par \tab \tab // if new process arrives in the system
\par \tab \tab if (!process_switch && ipQhead != NULL)
\par \tab \tab \tab if (timecount == ipQhead->arrival_time)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab struct Process *p;
\par \tab \tab \tab \tab p = ipQhead->next;
\par \tab \tab \tab \tab add_to_readyQ(ipQhead);
\par \tab \tab \tab \tab ipQhead = p;
\par \tab \tab \tab \tab process_switch = 1;
\par \tab \tab \tab \tab readyQ_updated = 1;
\par \tab \tab \tab \}
\par 
\par \tab \tab if (process_switch)
\par \tab \tab \{
\par \tab \tab \tab no_of_switches++;
\par \tab \tab \tab process_switch = 0;
\par \tab \tab \tab if (choice==1)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab printSimulation(curr,timecount,cputime, no_of_switches);
\par \tab \tab \tab \tab if (getch() == 'q' || getch() == 'Q')
\par \tab \tab \tab \tab \tab choice = 0;
\par \tab \tab \tab \}
\par \tab \tab \tab continue;
\par \tab \tab \}
\par \tab \tab if (readyQ_updated && readyQhead != NULL)
\par \tab \tab \{
\par \tab \tab \tab struct Process *temp;
\par \tab \tab \tab int min = 100;
\par \tab \tab \tab readyQ_updated = 0;
\par \tab \tab \tab temp = readyQhead;
\par \tab \tab \tab prev = NULL;
\par \tab \tab \tab // find the next shortest process
\par \tab \tab \tab // (add this) only if readyQ is updated
\par \tab \tab \tab while (temp!=NULL)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab if (temp->time_left < min)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab min = temp->time_left;
\par \tab \tab \tab \tab \tab curr = temp;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \tab temp = temp->next;
\par \tab \tab \tab \}
\par \tab \tab \tab // get the pointer to prev process (prev to min)
\par \tab \tab \tab // for manipulations
\par \tab \tab \tab temp = readyQhead;
\par \tab \tab \tab while (temp->next!=NULL)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab if (temp->next == curr)
\par \tab \tab \tab \tab \tab prev = temp;
\par \tab \tab \tab \tab temp = temp->next;
\par \tab \tab \tab \}
\par \tab \tab \tab // special case ie if shortest process is at the readyQhead
\par \tab \tab \tab if (prev == NULL)
\par \tab \tab \tab \tab prev = curr;
\par \tab \tab \} // if (readyQ_updated)
\par 
\par 
\par \tab \tab // execute io operation of the blockedQhead process
\par \tab \tab if (blockedQhead != NULL)
\par \tab \tab \{
\par \tab \tab \tab blockedQhead->time_left--;
\par \tab \tab \tab if (blockedQhead->io_head->next!=NULL)
\par \tab \tab \tab \tab blockedQhead->io_head->next->io_time_left--;
\par \tab \tab \tab blockedQhead->io_head->io_burst--;
\par \tab \tab \tab if (blockedQhead->io_head->io_burst == 0)
\par \tab \tab \tab \tab io_interrupt = 1;
\par \tab \tab \}
\par \tab \tab // execute the current running process
\par \tab \tab if (curr!=NULL)
\par \tab \tab \{
\par \tab \tab \tab curr->time_left--;
\par \tab \tab \tab if (curr->io_head != NULL)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab curr->io_head->io_time_left--;
\par \tab \tab \tab \tab if (curr->io_head->next != NULL)
\par \tab \tab \tab \tab \tab curr->io_head->next->io_time_left--;
\par \tab \tab \tab \}
\par \tab \tab \tab cputime++;
\par \tab \tab \}
\par \tab \tab timecount++;
\par \tab \tab if (choice==1)
\par \tab \tab \{
\par \tab \tab \tab printSimulation(curr,timecount,cputime,no_of_switches);
\par \tab \tab \tab if (getch() == 'q' || getch() == 'Q')
\par \tab \tab \tab \tab choice = 0;
\par \tab \tab \}
\par \tab \} // while
\par \tab clrscr();
\par \tab printf("Shortest Remaining Time\\n");
\par \tab printf("=======================\\n");
\par 
\par \tab fp = fopen("SRT.TXT","w");
\par \tab printResults(fp,timecount,cputime,no_of_switches);
\par \tab fclose(fp);
\par \tab freeMemory();
\par \} // srt
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid6257910 {\f1\insrsid6257910\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid6257910 ********}{\f1\insrsid6257910\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid12941189 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void round_robin(int choice, int QUANTUM)
\par \{
\par \tab int timecount = 0;
\par \tab int cputime = 0;
\par \tab int process_switch = 0;
\par \tab int no_of_switches = 0;
\par \tab FILE *fp;
\par 
\par \tab io_interrupt = 0;
\par \tab timeslice = 0;
\par \tab readyQhead   = NULL;
\par \tab blockedQhead = NULL;
\par \tab if (choice==1)
\par \tab \{
\par \tab \tab printSimulation(readyQhead,timecount,cputime,no_of_switches);
\par \tab \tab if (getch() == 'q' || getch() == 'Q')
\par \tab \tab \tab choice = 0;
\par \tab \}
\par \tab while (ipQhead!=NULL || readyQhead!=NULL || blockedQhead!=NULL)
\par \tab \{
\par \tab \tab // check currently executing process finishes or requests io
\par \tab \tab if (readyQhead != NULL)
\par \tab \tab \{
\par \tab \tab \tab // if process finishes, add it to opQ
\par \tab \tab \tab if (readyQhead->time_left == 0)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab struct Process *p;
\par \tab \tab \tab \tab readyQhead->tat = timecount - readyQhead->arrival_time;
\par \tab \tab \tab \tab p = readyQhead->next;
\par \tab \tab \tab \tab add_to_opQ(readyQhead);
\par \tab \tab \tab \tab readyQhead = p;
\par \tab \tab \tab \tab process_switch = 1;
\par \tab \tab \tab \tab timeslice = 0;
\par \tab \tab \tab \}
\par \tab \tab \tab // io request
\par \tab \tab \tab else if (readyQhead->io_head != NULL)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab // add to blockedQ
\par \tab \tab \tab \tab if (readyQhead->io_head->io_time_left == 0)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab struct Process *p;
\par \tab \tab \tab \tab \tab p = readyQhead->next;
\par \tab \tab \tab \tab \tab add_to_blockedQ(readyQhead);
\par \tab \tab \tab \tab \tab readyQhead = p;
\par \tab \tab \tab \tab \tab process_switch = 1;
\par \tab \tab \tab \tab \tab timeslice = 0;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab \}
\par \tab \tab \}
\par \tab \tab // check for io interrupt
\par \tab \tab if (!process_switch && io_interrupt)
\par \tab \tab \{
\par \tab \tab \tab struct Process *p;
\par \tab \tab \tab struct IO_Opn *temp_io;
\par 
\par \tab \tab \tab p = blockedQhead->next;
\par \tab \tab \tab blockedQhead->no_io_opns--;
\par \tab \tab \tab temp_io = blockedQhead->io_head;
\par \tab \tab \tab blockedQhead->io_head = blockedQhead->io_head->next;
\par \tab \tab \tab free (temp_io);
\par 
\par 
\par \tab \tab \tab if (blockedQhead->time_left != 0)
\par \tab \tab \tab \tab add_to_readyQ(blockedQhead);
\par \tab \tab \tab else
\par \tab \tab \tab \{
\par \tab \tab \tab \tab blockedQhead->tat = timecount - blockedQhead->arrival_time;
\par \tab \tab \tab \tab add_to_opQ(blockedQhead);
\par \tab \tab \tab \}
\par \tab \tab \tab io_interrupt = 0;
\par \tab \tab \tab blockedQhead = p;
\par \tab \tab \tab process_switch = 1;
\par \tab \tab \}
\par 
\par \tab \tab // check if new process arrives
\par \tab \tab if (!process_switch && ipQhead != NULL)
\par \tab \tab \tab if (timecount == ipQhead->arrival_time)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab struct Process *p;
\par \tab \tab \tab \tab p = ipQhead->next;
\par \tab \tab \tab \tab add_to_readyQ(ipQhead);
\par \tab \tab \tab \tab ipQhead = p;
\par \tab \tab \tab \tab process_switch = 1;
\par \tab \tab \tab \}
\par 
\par \tab \tab // check if timeslice is over
\par \tab \tab if (!process_switch && timeslice == QUANTUM)
\par \tab \tab \{
\par \tab \tab \tab process_switch = 1;
\par \tab \tab \tab timeslice = 0;
\par \tab \tab \tab // add the process to the end of readyQ
\par \tab \tab \tab if (readyQhead->next != NULL) // more than 1 processes in readyQ
\par \tab \tab \tab \{
\par \tab \tab \tab \tab struct Process *curr, *old_readyQhead;
\par \tab \tab \tab \tab curr = readyQhead;
\par \tab \tab \tab \tab old_readyQhead = readyQhead;
\par \tab \tab \tab \tab for (; curr->next!=NULL; curr=curr->next);
\par \tab \tab \tab \tab curr->next = readyQhead;
\par \tab \tab \tab \tab readyQhead = readyQhead->next;
\par \tab \tab \tab \tab old_readyQhead->next = NULL;
\par \tab \tab \tab \}
\par \tab \tab \} // timeslice over
\par 
\par \tab \tab if (process_switch)
\par \tab \tab \{
\par \tab \tab \tab no_of_switches++;
\par \tab \tab \tab process_switch = 0;
\par \tab \tab \tab if (choice==1)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab printSimulation(readyQhead,timecount,cputime, no_of_switches);
\par \tab \tab \tab \tab if (getch() == 'q' || getch() == 'Q')
\par \tab \tab \tab \tab \tab choice = 0;
\par \tab \tab \tab \}
\par \tab \tab \tab continue;
\par \tab \tab \}
\par 
\par \tab \tab // execute io of blockedQhead process
\par \tab \tab if (blockedQhead != NULL)
\par \tab \tab \{
\par \tab \tab \tab blockedQhead->time_left--;
\par \tab \tab \tab if (blockedQhead->io_head->next!=NULL)
\par \tab \tab \tab \tab blockedQhead->io_head->next->io_time_left--;
\par \tab \tab \tab blockedQhead->io_head->io_burst--;
\par \tab \tab \tab if (blockedQhead->io_head->io_burst == 0)
\par \tab \tab \tab \tab io_interrupt = 1;
\par \tab \tab \}
\par \tab \tab // execute the process at the readyQhead
\par \tab \tab if (readyQhead!=NULL)
\par \tab \tab \{
\par \tab \tab \tab readyQhead->time_left--;
\par \tab \tab \tab if (readyQhead->io_head != NULL)
\par \tab \tab \tab \{
\par \tab \tab \tab \tab readyQhead->io_head->io_time_left--;
\par \tab \tab \tab \tab if (readyQhead->io_head->next != NULL)
\par \tab \tab \tab \tab \tab readyQhead->io_head->next->io_time_left--;
\par \tab \tab \tab \}
\par \tab \tab \tab cputime++;
\par \tab \tab \tab timeslice++;
\par \tab \tab \}
\par \tab \tab timecount++;
\par \tab \tab if (choice==1)
\par \tab \tab \{
\par \tab \tab \tab printSimulation(readyQhead,timecount,cputime,no_of_switches);
\par \tab \tab \tab if (getch() == 'q' || getch() == 'Q')
\par \tab \tab \tab \tab choice = 0;
\par \tab \tab \}
\par \tab \} // while
\par 
\par \tab clrscr();
\par \tab printf("Round robin\\n");
\par \tab printf("===========\\n");
\par 
\par \tab fp = fopen("RR.TXT","w");
\par \tab printResults(fp,timecount,cputime,no_of_switches);
\par \tab fclose(fp);
\par \tab freeMemory();
\par \} // rr
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid9241218 {\f1\insrsid9241218\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid9241218 ********}{\f1\insrsid9241218\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void schedule(int algorithm)
\par \{
\par \tab int i;
\par 
\par \tab freeMemory();
\par 
\par \tab ipQhead = loadInputFromFile();
\par \tab opQhead = NULL;
\par 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid3695614 
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 \tab switch(algorithm)
\par \tab \{
\par \tab \tab case 1:
\par \tab \tab \{
\par \tab \tab \tab clrscr();
\par \tab \tab \tab printf("\\n\\n\\t\\t\\t======================");
\par \tab \tab \tab printf("\\n\\t\\t\\tFirst Come First Serve");
\par \tab \tab \tab printf("\\n\\t\\t\\t======================");
\par \tab \tab \tab i = printSimulationOptions();
\par \tab \tab \tab timeslice = -1;
\par \tab \tab \tab first_come_first_serve(i);
\par //\tab \tab \tab getch();
\par \tab \tab \tab getch();
\par \tab \tab \tab break;
\par \tab \tab \}
\par 
\par \tab \tab case 2:
\par \tab \tab \{
\par \tab \tab \tab clrscr();
\par \tab \tab \tab printf("\\n\\n\\t\\t\\t=====================");
\par \tab \tab \tab printf("\\n\\t\\t\\tShortest Process Next");
\par \tab \tab \tab printf("\\n\\t\\t\\t=====================");
\par \tab \tab \tab i = printSimulationOptions();
\par \tab \tab \tab timeslice = -1;
\par \tab \tab \tab shortest_process_next(i);
\par \tab \tab \tab getch();
\par \tab \tab \tab getch();
\par \tab \tab \tab break;
\par \tab \tab \}
\par \tab \tab case 3:
\par \tab \tab \{
\par \tab \tab \tab clrscr();
\par \tab \tab \tab printf("\\n\\n\\t\\t\\t=======================");
\par \tab \tab \tab printf("\\n\\t\\t\\tShortest Remaining Time");
\par \tab \tab \tab printf("\\n\\t\\t\\t=======================");
\par \tab \tab \tab i = printSimulationOptions();
\par \tab \tab \tab timeslice = -1;
\par \tab \tab \tab shortest_remaining_time(i);
\par \tab \tab \tab getch();
\par \tab \tab \tab getch();
\par \tab \tab \tab break;
\par \tab \tab \}
\par \tab \tab case 4:
\par \tab \tab \{
\par \tab \tab \tab int quantum = 0;
\par \tab \tab \tab clrscr();
\par \tab \tab \tab printf("\\n\\n\\t\\t\\t\\t===========");
\par \tab \tab \tab printf("\\n\\t\\t\\t\\tRound Robin");
\par \tab \tab \tab printf("\\n\\t\\t\\t\\t===========");
\par \tab \tab \tab printf("\\n\\n\\n\\t\\t\\tEnter the value of quantum : ");
\par \tab \tab \tab scanf("%d",&quantum);
\par \tab \tab \tab i = printSimulationOptions();
\par \tab \tab \tab round_robin(i,quantum);
\par \tab \tab \tab getch();
\par \tab \tab \tab getch();
\par \tab \tab \tab break;
\par \tab \tab \}
\par \tab \tab case 5 :
\par \tab \tab \{
\par \tab \tab \tab printProcessesInfo();
\par \tab \tab \tab getch();
\par \tab \tab \tab break;
\par \tab \tab \}
\par \tab \tab case 6 :
\par \tab \tab \{
\par \tab \tab \tab askInputOptions();
\par \tab \tab \tab break;
\par \tab \tab \}
\par \tab \tab case 7 :
\par \tab \tab \{
\par \tab \tab \tab generateProcesses();
\par \tab \tab \tab break;
\par \tab \tab \}
\par \tab \tab case 8 :
\par \tab \tab \{
\par \tab \tab \tab clrscr();
\par \tab \tab \tab compareResults();
\par \tab \tab \tab getch();
\par \tab \tab \tab break;
\par \tab \tab \}
\par \tab \tab default : exit(1);
\par \tab \}
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid4289350 {\f1\insrsid4289350\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid4289350 ********}{\f1\insrsid4289350\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void generateProcesses ()
\par \{
\par \tab int i,j;
\par \tab int times[101];
\par \tab int done;
\par \tab struct Process *temp;
\par \tab struct IO_Opn *temp_io;
\par 
\par \tab // before generating new processes, free up memory
\par \tab freeMemory();
\par 
\par \tab readyQhead = NULL;
\par \tab blockedQhead = NULL;
\par \tab opQhead = NULL;
\par \tab ipQhead = NULL;
\par 
\par \tab temp = NULL;
\par \tab temp_io = NULL;
\par 
\par \tab for (i=0;i<no_of_processes;i++)
\par \tab \tab times[i] = -1;
\par \tab if (RANDOMISE == 1)
\par \tab \tab randomize();
\par \tab for (i=1;i<=no_of_processes;i++)
\par \tab \{
\par \tab \tab temp = (struct Process *) malloc(sizeof(struct Process));
\par \tab \tab temp->io_head = NULL;
\par \tab \tab temp->arrival_time = rand_num(0,arrival_range);
\par \tab \tab done = false;
\par \tab \tab while (!done && i!=1)
\par \tab \tab \{
\par \tab \tab \tab for (j=1;j<i;j++)
\par \tab \tab \tab \tab if (times[j] == temp->arrival_time)
\par \tab \tab \tab \tab \{
\par \tab \tab \tab \tab \tab done = false;
\par \tab \tab \tab \tab \tab temp->arrival_time = rand_num(0, arrival_range);
\par \tab \tab \tab \tab \tab break;
\par \tab \tab \tab \tab \}
\par \tab \tab \tab else
\par \tab \tab \tab \tab done = true;
\par \tab \tab \}
\par \tab \tab times[i] = temp->arrival_time;
\par 
\par \tab \tab temp->no_io_opns = rand_num(0,no_io_opns);
\par 
\par \tab \tab if (temp->no_io_opns >= 1)
\par \tab \tab \{
\par \tab \tab \tab temp_io = (struct IO_Opn *)malloc(sizeof(struct IO_Opn));
\par \tab \tab \tab temp_io->io_burst = rand_num(1,7);
\par \tab \tab \tab temp_io->io_arrival = rand_num(1,5);
\par \tab \tab \tab temp_io->io_time_left = temp_io->io_arrival;
\par \tab \tab \tab temp_io->next = NULL;
\par \tab \tab \tab temp->io_head = temp_io;
\par \tab \tab \}
\par 
\par \tab \tab if (temp->no_io_opns == 2)
\par \tab \tab \{
\par \tab \tab \tab temp_io = (struct IO_Opn *)malloc(sizeof(struct IO_Opn));
\par \tab \tab \tab temp_io->next = NULL;
\par \tab \tab \tab temp_io->io_burst = rand_num(1,7);
\par \tab \tab \tab temp_io->io_arrival = rand_num(temp->io_head->io_arrival + temp->io_head->io_burst + 2,temp->io_head->io_arrival + temp->io_head->io_burst + 3);
\par \tab \tab \tab temp_io->io_time_left = temp_io->io_arrival;
\par \tab \tab \tab temp->io_head->next = temp_io;
\par \tab \tab \}
\par 
\par \tab \tab if (temp->io_head == NULL)
\par \tab \tab \tab temp->service_time = rand_num(1,20);
\par \tab \tab else
\par \tab \tab \{
\par \tab \tab \tab for (temp_io=temp->io_head;temp_io->next!=NULL;temp_io=temp_io->next);
\par \tab \tab \tab temp->service_time = temp_io->io_arrival + temp_io->io_burst + rand_num(1,6);
\par \tab \tab \}
\par 
\par \tab \tab temp->next = NULL;
\par \tab \tab if (ipQhead == NULL)
\par \tab \tab \tab ipQhead = temp;
\par \tab \tab else if (temp->arrival_time < ipQhead->arrival_time)
\par \tab \tab \{
\par \tab \tab \tab temp->next = ipQhead;
\par \tab \tab \tab ipQhead = temp;
\par \tab \tab \}
\par \tab \tab else
\par \tab \tab \tab add_to_ipQ(temp);
\par \tab \}
\par \tab setID();
\par \tab saveInputToFile();
\par \tab printProcessesInfo();
\par \tab getch();
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid10444896 {\f1\insrsid10444896\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid10444896 ********}{\f1\insrsid10444896\charrsid5393312 /
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid13458800 {\f1\insrsid5646542\charrsid6517298 void askInputOptions()
\par \{
\par \tab int option;
\par \tab clrscr();
\par \tab printf("\\n\\n\\t\\t      ====================================");
\par \tab printf("\\n\\t\\t      CPU SCHEDULING ALGORITHMS SIMULATION");
\par \tab printf("\\n\\t\\t      ====================================");
\par \tab printf("\\n\\n\\t\\t\\t1 : Use default input settings\\n");
\par \tab printf("\\n\\t\\t\\t2 : Change default input settings\\n");
\par \tab printf("\\n\\t\\t\\t3 : Quit\\n");
\par \tab printf("\\n\\n\\t\\t\\tEnter appropriate option : ");
\par \tab scanf("%d",&option);
\par 
\par \tab // before accepting new process input settings, free up memory
\par //\tab freeMemory();
\par 
\par \tab switch(option)
\par \tab \{
\par \tab \tab case 1 :
\par \tab \tab \tab no_of_processes = 10;
\par \tab \tab \tab no_io_opns = 2;
\par \tab \tab \tab arrival_range = no_of_processes-1;
\par \tab \tab \tab break;
\par 
\par \tab \tab case 2 :
\par \tab \tab \tab clrscr();
\par \tab \tab \tab printf("\\n\\n\\t\\t      ====================================");
\par \tab \tab \tab printf("\\n\\t\\t      CPU SCHEDULING ALGORITHMS SIMULATION");
\par \tab \tab \tab printf("\\n\\t\\t      ====================================");
\par 
\par \tab \tab \tab printf("\\n\\n\\t\\t    Enter the number of processes (Max 100) : ");
\par \tab \tab \tab scanf("%d",&no_of_processes);
\par \tab \tab \tab printf("\\n\\n\\t\\t    Enter the number of I/O operations (<= 2) : ");
\par \tab \tab \tab scanf("%d",&no_io_opns);
\par \tab \tab \tab printf("\\n\\n\\t\\t    Enter the max arrival time of a process (>= %d) : ", no_of_processes-1);
\par \tab \tab \tab scanf("%d",&arrival_range);
\par 
\par \tab \tab \tab if (no_io_opns > 2)
\par \tab \tab \tab \tab no_io_opns = 2;
\par \tab \tab \tab if (arrival_range < no_of_processes-1)
\par \tab \tab \tab \tab arrival_range = no_of_processes-1;
\par \tab \tab \tab break;
\par 
\par \tab \tab default : freeMemory(); exit(1);
\par \tab \}
\par \tab generateProcesses();
\par \}
\par }\pard \s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0\pararsid5646542 {\f1\insrsid7954212\charrsid5393312 /******************************************************************************************************}{
\f1\insrsid7954212 ********}{\f1\insrsid7954212\charrsid5393312 /}{\f1\insrsid13458800\charrsid5646542 
\par }}